#!/usr/bin/env python
# DTF Core Content
# Copyright 2013-2014 Jake Valletta (@jake_valletta)
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Generate DEX Databases for Applications
from argparse import ArgumentParser
from os import mkdir
from os.path import isdir, isfile
from pydtf import dtfglobals
from pydtf import dtfconfig
from pydtf.dtfcore import launch_binary
from pydtf import dtflog as log
from sys import argv, exit

import AppDb

import sqlite3

__VERSION__ = "1.2"

# dtf Python Module declaration
dtf_module = { "About" : "Create dexdb for an application or all applications.",
               "Author" : "Jake Valletta (jakev)",
               "Health" : "stable",
               "Version" : __VERSION__ }

PROJECT_DB = ''
AOSP_DB = ''

log.LOG_LEVEL_STDOUT = 5
                                   
TAG="appdexdb"

class AppDexDb():

    def __init__(self):

        self.local_appdb = AppDb.AppDb(
                            dtfconfig.get_prop("Local", "db-dir") + "/sysapps.db", safe=True)
        self.aosp_appdb = None

        self.sdk = dtfconfig.get_prop("Info", "sdk")
        self.system_apps_dir =  dtfconfig.get_prop("Local", "system-apps-dir")
        self.appdex_dir = dtfconfig.get_prop("Local", "db-dir") + "/appdexdbs"

    def processApplication(self, in_file, out_file):
        
        out, err, rtn = launch_binary("dexdumpsql.jar", "%s %s %s" % (in_file, out_file, self.sdk), launcher="java -jar")
        log.d(TAG, "Processing completed : %d" % rtn)
        return rtn

    def processApplications(self, app_list):

        rtn = 0

        if not isdir(self.appdex_dir):
            mkdir(self.appdex_dir)

        for app in app_list:

            project_name = app.project_name
            log.i(TAG, "Processing '%s'..." % project_name)

            odex_name = "%s/%s.odex" % (self.system_apps_dir, project_name)
            apk_name = "%s/%s.apk" % (self.system_apps_dir, project_name)
            out_name = "%s/%s.db" % (self.appdex_dir, project_name)

            vm_type = dtfconfig.get_prop("Info", "vmtype")

            if vm_type == "ART":
                if isfile(odex_name):
                    log.d(TAG, "ART ODEX mode selected.")
                    rtn |= self.processApplication(odex_name, out_name)            
                else:
                    log.w(TAG, "[WARNING] No ODEX for this application. '%s'" % project_name)

            elif isfile(odex_name):
                log.d(TAG, "ODEX mode selected.")
                rtn |= self.processApplication(odex_name, out_name)
            else:
                log.d(TAG, "APK mode selected.")
                rtn |= self.processApplication(apk_name, out_name)

        return rtn

    def getAllApplications(self):

            return self.local_appdb.getApps(dont_resolve=True)

    def getAllAospApplications(self):

        aosp_app_list = []

        aosp_app_list = [ i.project_name for i in self.aosp_appdb.getApps(dont_resolve=True) ]

        return [ i for i in self.local_appdb.getApps() if i.project_name not in aosp_app_list ]

def main(args):

    AOSP_DB = ("%s/%s-%s/dbs/sysapps.db" %
            (dtfglobals.DTF_PACKAGES, AppDb.AOSP_PACKAGE_PREFIX,
             dtfconfig.get_prop("Info", "sdk")))

    parser = ArgumentParser(prog='appdexdb',
                            description='Create dexdb for an application or all application.')
    parser.add_argument('application_name', metavar="application_name", type=str, nargs='?', default=None,
                        help='Process a single application.')
    parser.add_argument('--all-aosp', dest='aosp_mode', action='store_const', const=True,
                        default=False, help='Convert all AOSP applications.')
    parser.add_argument('--all', dest='all_mode', action='store_const', const=True,
                        default=False, help='Convert all applications.')
    parser.add_argument('--aosp-db', dest='aosp_db', default=AOSP_DB,
                        help='Use the specified AOSP database.')
                
    args = parser.parse_args()

    appdexdb = AppDexDb()

    # Is this all mode?
    if args.all_mode:
        log.i(TAG, "Doing all applications...")
        return appdexdb.processApplications( appdexdb.getAllApplications() )
    # What about only AOSP?
    elif args.aosp_mode:
        if args.aosp_db == None:
            aosp_db = AOSP_DB
            # Make sure that the AOSP_DB actually exists.
            if not AppDb.isAOSPDataInstalled():
                print "[ERROR] AOSP data for this API level is not installed. Please confirm it is!"
                return -2
        else:
            aosp_db = args.aosp_db
            if not isfile(aosp_db):
                print "[ERROR] File '%s' not found. Exiting." % aosp_db
                return -3

        appdexdb.aosp_appdb = AppDb.AppDb(aosp_db, safe=True)
        log.i(TAG, "Doing all AOSP frameworks...")
        return appdexdb.processApplications( appdexdb.getAllAospApplications() )
    # Single
    elif args.application_name != None:
        app_project = appdexdb.local_appdb.getAppByName(args.application_name)
        log.i(TAG, "Doing single application '%s'" % app_project)
        return appdexdb.processApplications( [app_project] )
    # ERROR
    else:
        print "[ERROR] You must supply an application name or --all/--all-aosp."
        return -1

if __name__ == '__main__':
        exit(main(argv))
